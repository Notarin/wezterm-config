exit
c
clear
q
exit
$nu.env-path
cd .config/
cd nushell/
l
ls
helix
exit
cd nu
z nu
scope aliases
cat .zoxide.nu
q
cat .zshrc
which cat
which rm
help rm
which trash
which clear
q
exit
c
cd nu
cd
sudo chsh notarin /usr/bin/nu
sudo chsh notarin
yay yubico pam
helix /etc/pam.d/sudo
sudoedit /etc/pam.d/sudo
sudo pam-auth-update --force --package<\n>
sudo /usr/sbin/pam-auth-update<\n>
fuck offf
thanks "fuck<\n><\n>"
yay pam u2f yubi
l /lib/security/
pamu2fcfg 
yay libpam-u2f
pamu2fcfg > ~/.config/Yu
pamu2fcfg > ~/.config/Yubico/u2f_keys
zsh pamu2fcfg > ~/.config/Yubico/u2f_keys
zsh
c
l /lib/security/
l /lib/security/ | wl-copy
helix
yes nice
q
exit
zellij a
cd nu
helix .zshrc
cd
helix .zshrc
helix
echo $SHELL
echo $env.SHELL
echo $env.XDG_CONFIG_HOME
echo $env.XDG_DATA_HOME
echo $env.XDG_STATE_HOME
echo $env.XDG_CACHE_HOME
echo press x to doubt
echo "press x to doubt"
ssh-agent -c
^ssh-agent -c<\n>    | lines<\n>    | first 2<\n>    | parse "setenv {name} {value};"<\n>    | transpose -r<\n>    | into record<\n>    | load-env
ssh-agent -c<\n>    | lines<\n>    | first 2<\n>    | parse "setenv {name} {value};"<\n>    | transpose -r<\n>    | into record<\n>    | load-env
cd helix
cd config
cd helix/
helix
helix config.toml
sudo pacman -R starship 
sudo pacman -R starship 
rm /var/lib/pacman/db.lck
sudo rm /var/lib/pacman/db.lck
sudo pacman -R starship 
btop
sudo pacman -S starship
text
test
^test
echo test
^echo test
^
few
dirs
use std/dirs<\n>
dirs
helix --health clipboard
wrow
helix config.toml
banner
kitty
sudo
run0
cd pam
cd /etc/pam.d/
l
ls
cd hypr
l
cat hyprland.conf
yay polkit
cat /etc/pam.d/polkit-1
cat sudo
cat system-auth
cp sudo polkit-1
sudo cp sudo polkit-1
run0 echo test
commandline
commandline edit
commandline
commandline edit
commandline edit s
commandline edit echo nice!
commandline edit echo "nice\!"
commandline edit "echo "nice\!""
commandline edit "echo \"nice\!\""
commandline edit "echo \"nice\""
echo "nice"
wev
wget https://github.com/nushell/nushell/releases/download/0.100.0/nu-0.100.0-x86_64-unknown-linux-gnu.tar.gz
ls nu-0.100.0-x86_64-unknown-linux-gnu.tar.gz
which q
cd nu
cat config.nu env.nu aliases.nu
cat config.nu env.nu aliases.nu | wl-copy 
history
history | where
where --help
history
history | where # > 120
history | where "#" > 120
where --help
ls
ls | where size > 1gb
history
history | sort-by command.len
sort-by --help
yay nerd-fonts
cat .config/kitty/kitty.conf
cat .config/kitty/current-theme.conf
cat .config/kitty/*
kitty list-fonts
c
cat .config/starship.toml
cat .config/starship.toml | wl-copy
starship 
starship config
starship explain
c
starship init nu
starship prest
starship preset
starship --help
cd /etc
wezterm
wezterm config
cd
cart .config/wezterm/wezterm.lua
cat .config/wezterm/wezterm.lua
cd /etc
helix .config/wezterm/wezterm.lua
killall wezterm
cd /etc
cd
cd hayabusa
l
cd hayabusa
l
save --help
starship --help
starship print-config
sleep
sleep 4
sleep 4s
sleep 4seconds
sleep 4
sleep 4s
sleep 4sec
exit
ssh localhost
starship explain
starship print-config
zsh
helix .config/wezterm/wezterm.lua
helix --help
helix --health
helix --health | wl-clipboard
helix --health | wl-copy
cat .config/helix/config.toml | wl-copy
cd nu
l
commandline edit "echo \"nice\""
echo "nice"
q
nano test
which nano
commandline
nano test
nano
nano test
scope aliases
which ssh-agent
-.-
nano test
nano 6sec
helix
cd nu
cd .config/nushell/
helix
q
exit
nano jfklej9 563463 543
nano jfklej9
xcowsay
cowsay
zsh
cd nu
hx
nvim .zshrc
hx $args
cd nu
nvim .zshrc
hx
sudo shutdown now
ssh nix
ssh nixos
ssh nix-os
cat .ssh/config
zsh
chsh
Hyprland
cd hypr
cat hyprland.conf
cat hyprland.conf | grep virt
cat hyprland.conf | grep virt | wl-copy 
pacman -Qt
yay jabref
let carapace_completer = {|spans|<\n>    carapace $spans.0 nushell ...$spans | from json<\n>}
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}
let zoxide_completer = {|spans|<\n>    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD}<\n>}
let fish_completer = ...<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # carapace doesn't have completions for asdf<\n>        asdf => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $carapace_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    # ...<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>    # ...<\n>}
let fish_completer = ...<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # carapace doesn't have completions for asdf<\n>        asdf => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $carapace_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # carapace doesn't have completions for asdf<\n>        asdf => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $carapace_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
carapace
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # carapace doesn't have completions for asdf<\n>        asdf => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $fish_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
cd hypr
cd
yay carapce
yay carapace
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # carapace doesn't have completions for asdf<\n>        asdf => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $carapace_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n>let zoxide_completer = {|spans|<\n>    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD}<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # carapace doesn't have completions for asdf<\n>        asdf => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $carapace_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n>let zoxide_completer = {|spans|<\n>    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD}<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $carapace_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n>let zoxide_completer = {|spans|<\n>    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD}<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # use zoxide completions for zoxide commands<\n>        __zoxide_z | __zoxide_zi => $zoxide_completer<\n>        _ => $fish_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
pacman -Qt
yay carapace
sudoedit /etc/pam.d/sudo
sudo echo
sudoedit /etc/pam.d/sudo
sudo echo
config nu
let fish_completer = {|spans|<\n>    fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>    | from tsv --flexible --noheaders --no-infer<\n>    | rename value description<\n>}<\n><\n>let carapace_completer = {|spans: list<string>|<\n>    carapace $spans.0 nushell ...$spans<\n>    | from json<\n>    | if ($in | default [] | where value =~ '^-.*ERR$' | is-empty) { $in } else { null }<\n>}<\n><\n>let zoxide_completer = {|spans|<\n>    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD}<\n>}<\n><\n># This completer will use carapace by default<\n>let external_completer = {|spans|<\n>    let expanded_alias = scope aliases<\n>    | where name == $spans.0<\n>    | get -i 0.expansion<\n><\n>    let spans = if $expanded_alias != null {<\n>        $spans<\n>        | skip 1<\n>        | prepend ($expanded_alias | split row ' ' | take 1)<\n>    } else {<\n>        $spans<\n>    }<\n><\n>    match $spans.0 {<\n>        # carapace completions are incorrect for nu<\n>        nu => $fish_completer<\n>        # fish completes commits and branch names in a nicer way<\n>        git => $fish_completer<\n>        # main completion engine<\n>        _ => $fish_completer<\n>    } | do $in $spans<\n>}<\n><\n>$env.config = {<\n>    completions: {<\n>        external: {<\n>            enable: true<\n>            completer: $external_completer<\n>        }<\n>    }<\n>}
pacman -Qti
gitui
cat .ssh/authorized_keys
cat .ssh/yubikey.pub
ssh-keygen --help
man ssh-keygen
man ssh-keygen | wl-copy
cd .ssh
cat yubikey.pub
cat yubikey.pub | wl-copy 
ping wogo.dev
iwctl
yay todoist
yay taskwarrior web
gem install taskwarrior-web
task-web
l
ls
task-web
gem --help
gem list
gem which task-web
gem which taskwarrior-web
taskwarrior-web
gem which taskwarrior-web
gem which taskwarrior-web | wl-copy 
/home/notarin/.local/share/gem/ruby/3.3.0/gems/taskwarrior-web-1.1.12/lib/taskwarrior-web.rb<\n>
yay gem
ruby --help
rub gem
ruby gem
ruby task-web
yay ruby-dev
yay ruby
yay rubygems
gem env user_gemhome
gem env user_gemhome | wl-copy 
/home/notarin/.local/share/gem/ruby/3.3.0/bin/task-web
yay paru-bin
man paru
cd confi
mkdir paru
cd paru
touch paru.conf
paru plex
man 5 paru.conf
nu --help
fimsh
which fish
fimsh
which fish
which fimsh
cd hypr
hx
cd nu
use ~/.cache/starship/init.nu
cat ~/.cache/starship/init.nu
starship prompt
c
ls
emacs
yay emacs
emacs
ls
test = "test"
$test = "test"
test = "test"
$env
$env.PROMPT_MULTILINE_INDICATOR = "::: "
let test
let test = {}
$test
$test.one = 1
$test | describe
mut test = {}
$test.one = 1
$test.two = 2
$test | describe
$test
$test = {<\n>three: 3<\n>four: 4<\n>}
$env = {}
which merge
merge --help
mut onetwo = {}
mut threefour = {}
onetwo.one = 1
$onetwo.one = 1
$onetwo.two = 2
$onetwo
$threefour.three = 3
$threefour.four = 4
$threefour
merge --help
mut test = {}
$onetwo | merge $test
$test
mut collection = [ $onetwo, $threefour ]
$collection
flatten 
flatten --help
$env
$env | flatten
$collection
$collection | flatten
$collection
$collection | each
$collection | each {}
$collection | each {echo}
$collection | each {|e| e}
$collection | each {|e| $e}
$collection | each {|item| $item}
$collection | each {|item|}
$collection | each {<\n>|item|<\n>mut new = {}<\n>$new}
mut new = {}
$collection | each {<\n>|item|<\n>}
$collection | each {<\n>|item|<\n>$item | merge $new<\n>}
/tmp/collect.nu
nu /tmp/collect.nu
mut new = {}
nu /tmp/collect.nu
print
nu /tmp/collect.nu
which print
help print
nu /tmp/collect.nu
insert --help
nu /tmp/collect.nu
append
nu /tmp/collect.nu
combine
def combineListOfRecord [listOfRecords] {<\n>    $listOfRecords | reduce {<\n>        |it, acc|<\n>        $acc | merge $it<\n>    }<\n>}
mut onetwo = {}<\n>mut threefour = {}<\n>mut fivesix = {}<\n>let props = {<\n>    single: 1<\n>    multi: {<\n>        first: 1<\n>        second: 2<\n>    }<\n>    nested: {<\n>        firstmulti: {<\n>            first: 1<\n>            second: 2<\n>        }<\n>        secondmulti: {<\n>            first: 1<\n>            second: 2<\n>        }<\n>    }<\n>}<\n><\n>$onetwo.one = 1<\n>$onetwo.two  = 2<\n>$threefour.three = 3<\n>$threefour.four = 4<\n>$fivesix.five = 5<\n>$fivesix.six = 6<\n><\n>print "\$onetwo:"<\n>print $onetwo<\n>print "\$threefour:"<\n>print $threefour<\n>print "\$fivesix:"<\n>print $fivesix<\n>print "\$props:"<\n>print $props<\n><\n>mut list = []<\n><\n>print "\$list"<\n>print $list<\n><\n>print ""<\n><\n>$list = ($list | append $onetwo)<\n>$list = ($list | append $threefour)<\n>$list = ($list | append $fivesix)<\n>$list = ($list | append $props)<\n><\n>print "\$list:"<\n>print $list
$list
combineListOfRecords 
def combineListOfRecords [listOfRecords] {<\n>    $listOfRecords | reduce {<\n>        |it, acc|<\n>        $acc | merge $it<\n>    }<\n>}
combineListOfRecords 
combineListOfRecords $list
$env
$nu.data-dir
$nu.data-dir | path join 'completions'
ls /home/notarin/.local/share/nushell/completions/
ls /home/notarin/.local/share/nushell/
ls /home/notarin/.local/share
c
import
import --help
whcihwhich import
which import
source --help
source
$nu.data-dir | path join 'completions'
$nu.default-config-dir | path join 'plugins'
$nu.default-config-dir | path join 'plugins' | ls
$nu.default-config-dir | path join 'plugins'
$nu.default-config-dir | path join 'plugins' | wl-copy
ls /home/notarin/.config/nushell/plugins
ls /home/notarin/.config/nushell/
cat ~/.zoxide.nu
zoxide init nushell
cd
source --help
nu zoxide init nushell
zoxide init nushell
zoxide init nushell | source
trash .zoxide.nu
starship init nu
ssh-agent -c
which ssh-agent
which ^ssh-agent
use --help
export
$env
sleep 5
sleep 5sec
is
[]
which fimsh
[]
[1]
[]
if --help
[] | length
if ([] | length) > 0 {true}
if ([1] | length) > 0 {true}
if ([1] | length) > 0 {true} else {false}
if ([] | length) > 0 {true} else {false}
def check-executable-binary [command_name] {<\n>    let which = which $command_name<\n>    if ($which | length) > 0 {true} else {false}<\n>}
check-executable-binary fish
check-executable-binary fimsh
zoxide init nushell
c
zoxide init nushell
cd nu
__zoxide_z nu
alias z = __zoxide_z
__zoxide_z nu
alias z = __zoxide_z
__zoxide_z nu
zoxide init nushell
zoxide --help
$env.config
$env.config.hooks
$env.config.hooks.env_change
$env.config.hooks.env_change.PWD
$env.config.hooks.env_change.PWD[0]
$env.config.hooks.env_change.PWD
print $env.config.hooks.env_change.PWD
print -r $env.config.hooks.env_change.PWD
$env.config.hooks.env_change.PWD
$env.config
$env.config.hooks
config env --default | nu-highlight | lines
config nu --default | nu-highlight | lines<\n>
config nu --default | nu-highlight | lines
$env.config.hooks
$env.config.hooks.env_change
$env.config.hooks.env_change.PWD
def check-executable-binary [command_name] {<\n>    let which = which $command_name<\n>    if ($which | length) > 0 {true} else {false}<\n>}<\n><\n>let fish_completer = {<\n>    engine: {|spans|<\n>        fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>        | from tsv --flexible --noheaders --no-infer<\n>        | rename value description<\n>    }<\n>    valid: (check-executable-binary "fish")<\n>}
$fish_completer.valid
def check-executable-binary [command_name] {<\n>    let which = which $command_name<\n>    if ($which | length) > 0 {true} else {false}<\n>}<\n><\n>let fish_completer = {<\n>    engine: {|spans|<\n>        fish --command $'complete "--do-complete=($spans | str join " ")"'<\n>        | from tsv --flexible --noheaders --no-infer<\n>        | rename value description<\n>    }<\n>    valid: (check-executable-binary "fimsh")<\n>}
$fish_completer.valid
mkdir special_dir
cd special_dir/
z
cd special_dir/
__zoxide_z
zoxide init nushell
cd special_dir/
cd
zoxide edit
cd special_dir/
let zoxide_completer = {|spans|<\n>    $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD}<\n>}
mkdir stupid_dir
cd stupid_dir/
cd /
cd stu
z
__zoxide_z
z
cat /tmp/.zoxide.nu
cd stu
which cd
cd
ssh-agent -c
cd nu
l
cat history.txt 
cat aliases.nu completion_engine.nu config.nu env.nu functions.nu starship.nu themes.nu zoxide.nu 
cat aliases.nu completion_engine.nu config.nu env.nu functions.nu starship.nu themes.nu zoxide.nu | wl-copy 
cat aliases.nu completion_engine.nu config.nu env.nu functions.nu starship.nu themes.nu zoxide.nu 
tree
hx
cd nu
hx
sudoedit /etc/pam.d/sudo
hx
cat .zsh_options 
cd wez
l
edit wezterm.lua
man edit
pacman -Qi editr
pacman -Qi edit
pacman -Qi editline 
pacman -Qi edit
pacman -Qi ed
pacman -Qi e
pacman -Qi | grep edit
man edit
ex
pacman -Qi ex
pacman -Qlb 
pacman -Ql ex
pacman -Ql
pacman -Ql | grep ex
pacman -Ql | grep " ex"
pacman -Ql | grep "/ex"
pacman -Ql | grep --regex
pacman -Ql | grep --regexp
pacman -Ql | grep --regexp "/ex"$ 
pacman -Rns vi
sudo pacman -Rns vi
edit wezterm.lua
nu --help
zsh --help
bash --help
$env.SHELL
nu --help
zellij ls
zellij ls | lines
zellij a
zellij ls
zellij ls | lines
zellij --help
zellij a likable-yak [Created 2days 3h 56m 17s ago]
zellij a "likable-yak [Created 2days 3h 56m 17s ago]"
zellij ls | lines
zellij
zellij ls | lines
zellij ls | lines | split column " "
zellij ls | lines | split -n 2 column " "
zellij ls | lines | split column -n 2 " "
fzf --help
zellij ls
zellij ls | fzf
let sessions = (<\n>    [a, b]; zellij ls | lines | split column -n 2 " "<\n>)
$sessions
let options: table = [["Title", "Handle"]; ["No session", "none"]]<\n>
$options
$sessions
let options = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines | split column -n 2 " "<\n>)<\n><\n>let options = $options ++ ($sessions | each { |row| [$row.column1 + " " + $row.column2, $row.column1] })<\n><\n>$options<\n>
let options: table<Title: string, Handle: string> = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines | split column -n 2 " "<\n>)<\n><\n>let options: table<Title: string, Handle: string> = $options ++ ($sessions | each { |row| [$row.column1 + " " + $row.column2, $row.column1] })<\n><\n>$options<\n>
$options
$options | describe
let options = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines | split column -n 2 " "<\n>)<\n><\n>let options = $options | append ($sessions | each { |row| [$row.column1 + " " + $row.column2, $row.column1] })<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines | split column -n 2 " " | rename column1 Title | rename column2 Handle<\n>)<\n>
(<\n>    zellij ls | lines | split column -n 2 " " | rename column1 Title | rename column2 Handle<\n>)
rename --help
(<\n>    zellij ls | lines | split column -n 2 " " | rename Title Handle<\n>)
append --help
let options = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines | split column -n 2 " " | rename Title Handle<\n>)<\n><\n>let options = $options | append $sessions<\n><\n>$options<\n>
let options = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines | split column -n 2 " "<\n>)<\n><\n>let options = $options | append $sessions<\n><\n>$options<\n>
(<\n>    zellij ls | lines<\n>) | each {|string| [[Title, Handle]; [$string, ""]]}
zellij
(<\n>    zellij ls | lines<\n>) | each {|string| [[Title, Handle]; [$string, ""]]}
(<\n>    zellij ls | lines<\n>) | map {|string| [[Title, Handle]; [$string, ""]]}
let options = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = $options | append $sessions<\n><\n>$options<\n>
let options = [["Title", "Handle"]; ["No session", "none"]]<\n><\n>let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = [["Title"];] ++ ($sessions | each { |row| [$row] })<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = [["Title"];] ++ ($sessions | each { |row| $row })<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = [["Title"];] ++ ($sessions | each { |row| [$row] })<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = $sessions<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = ($sessions | each { |row| {Title: $row, foo: "whatever"} })<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = ($sessions | each { |row| {Title: $row, Handle: "whatever"} })<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = ($sessions | each { |row| <\n>    let parts = ($row | split column -n 2 " "); <\n>    {Title: $row, Handle: $parts.0} <\n>})<\n><\n>$options<\n>
$options
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = ($sessions | each { |row| <\n>    let parts = ($row | split column -n 2 " "); <\n>    {Title: $row, Handle: $parts.column1} <\n>})<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = ($sessions | each { |row| <\n>    let parts = ($row | split column -n 2 " "); <\n>    {Title: $row, Handle: ($parts.column1 | str join)} <\n>})<\n><\n>$options<\n>
let sessions = (<\n>    zellij ls | lines<\n>)<\n><\n>let options = ($sessions | each { |row|<\n>    let parts = ($row | split column -n 2 " ");<\n>    {Title: $row, Handle: ($parts.column1 | str join)}<\n>})<\n><\n>let options = [{Title: "New session", Handle: "new"}, {Title: "No session", Handle: "none"}] ++ $options<\n><\n>$options<\n>
$options | fzf
$options --raw | fzf
print --raw $options | fzf
print --raw $options
$options.Title
$options.Title | fzf
print --raw $options.Title
print $options.Title
print --raw $options.Title
print --raw $options.Title | fzf
print --help
echo $options.Title
echo --raw $options.Title
echo --help $options.Title
print --raw $options.Title | fzf
print --raw $options.Title | fzf --help
print --raw $options.Title | fzf --
(print --raw $options.Title) | fzf --
print --help
echo --help
man echo
$options.Title | fzf
raw
$options.Title | fzf
$options.Title | input
$options.Title | input list
$options.Title | input list -f
$options
input --help
input listen
$options | input list -f
(<\n>    zellij ls | lines<\n>)
(<\n>    zellij ls | lines | split columns 2 " "<\n>)
split --help
(<\n>    zellij ls | lines | split column 2 " "<\n>)
split column --help
(<\n>    zellij ls | lines | split column --number 2 " "<\n>)
(<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1
(<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1 | describe
let sessions: list<string> = (<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>$options<\n>
let sessions: list<string> = (<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>let choice = $options | input list -f
let sessions: list<string> = (<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>let choice = $options | input list -f<\n><\n>print $choice<\n>print $choice<\n>print $choice<\n>print $choice<\n>print $choice<\n>print $choice<\n>
eval
exec
exec --help
nu
let sessions: list<string> = (<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>let choice = $options | input list -f<\n><\n>match $choice {<\n>    "No Session" => "nu"<\n>    "New Session" => "zellij"<\n>    _ => "zellij attach $choice"<\n>}<\n><\n>exec $choice
let sessions: list<string> = (<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>let choice = $options | input list -f<\n><\n>let smtn: string = match $choice {<\n>    "No Session" => "nu"<\n>    "New Session" => "zellij"<\n>    _ => "zellij attach $choice"<\n>}<\n><\n>exec $smtn
exec --help
exec "zellij attach $choice"
exec --help
iwctl
zellij --help
iwctl
let sessions: list<string> = (<\n>    zellij ls | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>let choice = $options | input list -f<\n><\n>let smtn: string = match $choice {<\n>    "No Session" => (exec nu)<\n>    "New Session" => (exec zellij)<\n>    _ => (zellij attach $choice)<\n>}<\n>
zellij --help
zellij list-sessions --help
zellij list-sessions -n
let sessions: list<string> = (<\n>    zellij ls -n | lines | split column --number 2 " "<\n>).column1<\n><\n>let meta_options: list<string> = ["No Session", "New Session"]<\n><\n>let options: list<string> = $sessions | append $meta_options<\n><\n>let choice = $options | input list -f<\n><\n>let smtn: string = match $choice {<\n>    "No Session" => (exec nu)<\n>    "New Session" => (exec zellij)<\n>    _ => (exec zellij attach $choice)<\n>}<\n>
zellij list-sessions -n
zellij
zellij list-sessions -n
zellij
cd nu
mv test.nu zellij.nu
zellij list-sessions -n
zellij list-sessions --help
(<\n>    zellij ls -n | lines | split column --number 2 " "<\n>).column1 e>| echo
if --help
$sessions | length
let sessions: list<string> = (<\n>    zellij ls -n | lines | split column --number 2 " "<\n>).column1
$sessions | length list
$sessions | length
cat .zshrc
ssh nix-box
l
ls nixos-mount/
sshfs --help
yay sshfs
sshfs --help
tldr sshfs
sshfs nix-box nixos-mount/
sshfs nixos.local nixos-mount/
sshfs nix-box:nixos-mount/
sshfs nix-box:~ nixos-mount/
sshfs nixos.local:~ nixos-mount/
sshfs 192.168.122.34:~ nixos-mount/
sshfs notarin@192.168.122.34:~ nixos-mount/
sshfs notarin@192.168.122.34 nixos-mount/
sshfs notarin@192.168.122.34:~ nixos-mount/
sshfs notarin@192.168.122.34:/home/notarin nixos-mount/
hostname
git add --help
c
cd helix
cat .zshrc
cat config.toml 
ssh nix-box
sshfs notarin@192.168.122.34:/home/notarin nixos-mount/
chsh
cd zellij
l
ls themes/
cat config.toml 
zellij setup --check
zellij --help
cd zellij
cat config.kdl 
cat config.kdl 
which zellij
zsh
c
ssh nix-box
ls
c
super dnagerious command
ssh nix-box
ssh nix-box
wezterm --help
pacman -Q wezterm-git 
cd wez
cat wezterm.lua 
cat wezterm.lua  | wl-copy 
git push
cd wez
ls
echo $env.TERM
$env.TERM
$env.TERM
env.TERM = xterm-256color
$env.TERM | describe
env.TERM = "xterm-256color"
$env.TERM = "xterm-256color"
$env.TERM
$env.COLORTERM
$env.COLORTERM
btop
$env.SHELL
zsh
killall Hyprland 
cat ~/.config/nushell/zellij.nu 
cat ~/.config/wezterm/wezterm.lua 
ssh nix-box
cat ~/.config/nushell/zellij.nu | wl-copy
cat ~/.config/wezterm/wezterm.lua | wl-copy
bat ~/.config/wezterm/wezterm.lua 
cat ~/.config/wezterm/wezterm.lua 
cat --style=none ~/.config/wezterm/wezterm.lua 
cat --style ~/.config/wezterm/wezterm.lua 
cat --style non e~/.config/wezterm/wezterm.lua 
cat --style simple ~/.config/wezterm/wezterm.lua 
cat --help
cat --style plain ~/.config/wezterm/wezterm.lua 
btop && c
btop and c
btop ; c
btop
btop --utf-force
yay mumble
yay nix
yay nixpkgs
yay intellij idea runtime
yay idea runtime
yay idea
paru nixd
paru nlohmann_json
paru nixd
paru idea
paru -Qm
cat /etc/shells 
/usr/bin/systemd-home-fallback-shell
systemd-home-fallback-shell
systemd-home-fallback-shell --help
man systemd-home-fallback-shell
cd ~/.config/systemd/user/custom-shell.service
hx ~/.config/systemd/user/custom-shell.service
systemctl --user enable --now custom-shell.service
hx ~/.config/systemd/user/custom-shell.service
systemctl --user restart custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
hx ~/.config/systemd/user/custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
l /dev/
l /dev/ | where name tty2
l /dev/ | where name "tty2"
l /dev/ | where name --help
l /dev/ | where --help
l /dev/
l /dev/ | where --help
l /dev/ | where name =~ "^tty"
l /dev/ | where name =~ "$tty"
l /dev/ | where name =~ "tty"
l /dev/ | where name =~ "pty"
l /dev/ | where name =~ "pts"
cat /dev/pts
l /dev/pts
ls --help
ls -la
la /dev/pts
ls -la /dev/pts
cat /dev/pts/8
cat /dev/pts/10
/dev/pts/10
"test"
"test" | save /dev/pts/10
"test" | save -f /dev/pts/10
al
hx ~/.config/systemd/user/custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
ls -la /dev/pts
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
hx ~/.config/systemd/user/custom-shell.service
systemctl --user status custom-shell.service
ls -la /dev/pts
tty
hx ~/.config/systemd/user/custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
hx ~/.config/systemd/user/custom-shell.service
ls -la /dev/pts
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user daemon-reload 
ls -la /dev/pts
systemctl --user restart custom-shell.service
ls
cat /etc/shells
cat /etc/passwd 
/usr/bin/nologin
cat /etc/passwd 
/bin/false
c
chsh
chsh -l
pacman -Q systemd-homed
yay systemd-homed
pacman -Qo /usr/bin/systemd-home-fallback-shell 
systemd-homed
/usr/bin/systemd-home-fallback-shell
pacman -Qo /bin/rbash
man --help
tldr man
man --whatis chsh
man --html chsh
man --html=chrome chsh
man --html=google-chrome-stable chsh
man chsh
man lchsh
man chsh
man lchsh
man chsh
man man
yay lchsh
pacman -F
pacman -F lchsh
pacman -F chsh
man chsh
libuser
yay libuser
cat ~/.config/systemd/user/custom-shell.service
ls
l
ls -la /dev/pts
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
yes yesy
man trap
tldr trap
tty
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
/usr/bin/echo testttttttttttttttttttttttttttttttttttttttttttttttttt<\n>
/usr/bin/echo testttttttttttttttttttttttttttttttttttttttttttttttttt
/usr/bin/echo testttttttttttttttttttttttttttttttttttttttttttttttttt | save -f /dev/pts/10
systemctl --user status custom-shell.service
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
/usr/bin/sleep
/usr/bin/sleep 5
/usr/bin/sleep 2
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
/usr/bin/whoami
systemctl --user daemon-reload 
systemctl --user restart custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload ;
systemctl --user daemon-reload ;\
systemctl --user daemon-reload ;
systemctl --user daemon-reload
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
ls -la /dev/pts
ls -la /dev/pts/10
(ls -la /dev/pts/10).name
(ls -la /dev/pts/10).mode
[ (ls -la /dev/pts/10).mode, (ls -la /dev/pts/10).mode]
print [ (ls -la /dev/pts/10).mode, (ls -la /dev/pts/10).mode]
(ls -la /dev/pts/10).mode
print [[ (ls -la /dev/pts/10).mode, (ls -la /dev/pts/10).mode ]]
(ls -la /dev/pts/10).mode
{ (ls -la /dev/pts/10).mode, (ls -la /dev/pts/10).mode }
{ (ls -la /dev/pts/10).mode (ls -la /dev/pts/10).mode }
(ls -la /dev/pts/10).mode
ls -la /dev/pts/10
ls -la /dev/pts/10 | select name mode user group readonly
ls -la /dev/pts/10
ls -la /dev/pts/10 | select name mode user group readonly
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
systemctl --user --tty
systemd-run --user --tty /usr/bin/bash
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
agetty --help
agetty
tldr agetty
agetty 2
exit
agetty 8
agetty pts/12
ls -la /dev/pts/10
ls -la /dev/pts
agetty -8 â€“ linux
agetty -a notarin tty
agetty -a notarin tty8
agetty -a notarin tty7
screen --help
tty
screen -r pts/11
screen -r pts11
screen -r pts
screen -m
screen -ls
systemctl --user -l status custom-shell.service
systemctl --user -l  status custom-shell.service
systemctl --user status custom-shell.service
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
chmod a+rw /dev/pts/10
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
dmesg
sudo dmesg
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
sudo dmesg
journalctl
sudo ausearch -m avc -ts recent
sudo journalctl | grep "denied"
sudo journalctl
sudo journalctl --help
sudo journalctl -xe
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
sudo journalctl -xe
dmesg
sudo dmesg
sudo dmesg -xe
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
ls -la /dev/pts
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
groups
usermod --help
groups
usermod -aG tty notarin
sudo usermod -aG tty notarin
groups
id -g
id --help
id -g tty
id
systemctl --user daemon-reload ; systemctl --user restart custom-shell.service ; systemctl --user status custom-shell.service
su notarin
sudo usermod -rG tty notarin
id
groups
ls -la /dev/pts
ls -la /dev/ptmx
ls -la /dev/pts
grantpt
strace
strace ls
strace grantpt
syscall
yay syscall
/dev/ptmx
cat /dev/ptmx
tldr socat
socat --help
zsh
socat -h
socat -U - UNIX-CONNECT:/dev/ptmx
zsh
write
write --help
man stty
stty
$env.SHELL
kitty
$env.SHELL
$env.SHELL = /usr/bin/zsh
$env.SHELL = "/usr/bin/zsh"
$env.SHELL
kitty
wezterm
$env.SHELL
wezterm
killall wezterm-gui 
zellij a
echo $SHELL
$env.SHELL
$env.SHELL = "/usr/bin/zsh"
$env.SHELL
wezterm
$env.SHELL
ls -la /etc/passwd
chsh --help
which chsh
cat /usr/bin/chsh
ls -la /usr/bin/chsh
suid
ptrace
yay ptrace
yay syscall
c
$env
cat /etc/shells
which noshell
yay noshell
tldr find
find --help
zsh
zsh
hx ~/.config/systemd/user/custom-shell.service
wev
cd hypr
hyprctl devices
hx binds.conf 
c
ls /home/notarin/.steampath/
ls /home/notarin/.steam/steam/
pacman -Q
pacman -Q | steam
pacman -Q | grep steam
sudo pacman -Rns steamcmd 
ls ~/.local/share/applications/
ls ~/.local/share/applications/ | where name steam
ls ~/.local/share/applications/ | where name Bej
ls ~/.local/share/applications/ | where name "Bej"
where name --help"Bej"
where name --help
where --help
ls ~/.local/share/applications/ | where name =~ "Bej"
ls ~/.local/share/applications/ | where name =~ "steam"
cat /home/notarin/.local/share/applications/steam.desktop
cd /home/notarin/.local/share/Steam/
l
steam.sh
./steam.sh
ls /tmp/dumps
ls /tmp/dumps/
hex
yay hex
hex libsteam_api.so
hexdump libsteam_api.so 
socat -U - UNIX-CONNECT:/dev/ptmx
zsh
socat -U - UNIX-CONNECT:$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock
socat -U - UNIX-CONNECT:$env.XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock
socat -U - UNIX-CONNECT:${env.XDG_RUNTIME_DI}R/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock
socat -U - UNIX-CONNECT:($env.XDG_RUNTIME_DIR)/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock
socat -U - UNIX-CONNECT:($env.XDG_RUNTIME_DIR)/hypr/($env.HYPRLAND_INSTANCE_SIGNATURE)/.socket2.sock
cd hypr
hx hyprland.conf 
cat /etc/pam.d/su
su
c
hx /etc/pam.d/su
sudoedit /etc/pam.d/su
sudo su
c
sudo su
unshare --user --pid echo YES
Hyprland
ncdu
df -h
sudo btrfs filesystem
sudo btrfs filesystem usage /
sudo btrfs subvolume list /
sudo btrfs filesystem show
sudo btrfs subvolume
sudo btrfs subvolume list
sudo btrfs subvolume list /
sudo btrfs subvolume
sudo btrfs subvolume delete .snapshots/1666/snapshot
sudo btrfs subvolume delete /.snapshots/1666/snapshot
cd .snapshots
cd /.snapshots
sudo btrfs subvolume delete /.snapshots/*/snapshot
sudo btrfs subvolume list /
sudo btrfs filesystem usage /
cd
cd /
sudo ncdu
sudo btrfs --help
sudo btrfs filesystem usage /
sudo btrfs filesystem defrag /
cd
sudo btrfs filesystem defrag ~
sudo btrfs filesystem usage /
df -h
sudo pacman -Syu
yay
sudo reboot
zoxide init nushell | save -f /tmp/.zoxide.nu
q
exit
yay sniffnet
yay htpc
btop
ssh nix-box
sshfs notarin@192.168.122.34:/home/notarin nixos-mount/
cd sys
cd
zi sys
cd nixos-mount/sys_flake/
l
git add .
git commit -m "First stable system configuration"
netcat --help
nix
nix --help
c
nix
l /etc/ssh
btop --utf-force
killall steam
yay helvetica
yay gothic
yay gothic ttf
yay rocket league
yay heroic
killall steamwebui
btop
btop --utf-force
killall steamwebhelper
btop
cd /var/lib/libvirt/images/
qemu-img info `Windows 11.qcow2`
sudo qemu-img info `Windows 11.qcow2`
sudo qemu-img --help
sudo qemu-img resize --help
sudo qemu-img
sudo qemu-img info `Windows 11.qcow2`
sudo qemu-img resize "Windows 11.qcow2" 100GiB
sudo qemu-img resize "Windows 11.qcow2" 100G
sudo qemu-img info `Windows 11.qcow2`
sudo qemu-img resize "Windows 11.qcow2" 130G
qemu-nbd
modprobe nbd max_part=8
sudo modprobe nbd max_part=8
cd /var/lib/libvirt/images/
qemu-nbd --connect=/dev/nbd0 `Windows 11.qcow2`
sudo qemu-nbd --connect=/dev/nbd0 `Windows 11.qcow2`
fdisk /dev/nbd0 -l<\n>
sudo fdisk /dev/nbd0 -l
sudo gdisk /dev/nbd0
yay gdisk
sudo gdisk /dev/nbd0
parted
sudo parted /dev/nbd0
gparted
gparted --help
sudo gparted /dev/nbd0
gparted /dev/nbd0
qemu-nbd --disconnect=/dev/nbd0
qemu-nbd --disconnect /dev/nbd0
sudo qemu-nbd --disconnect /dev/nbd0
qemu --help
qemu-x86_64 
qemu-x86_64 --help
qemu-system-x86_64 -device help | grep virtio<\n>
qemu-system-x86_64 -device help | grep virtio
qemu-system-x86_64 --version<\n>
mkpasswd --help
yay mkpasswd
ping google.com
man 3 crypt
ssh alisa.local
iwctl
gitui
helix .gitignore
gitui
helix .gitignore
cat .config/nushell/
ls .config/nushell/
cd nvim
l
tldr tar
tar czf ~/Documents/rust-nvim-config-rust.tar.gz
yay 7zip
sudo pacman -Ss 7zip
yay 7zip
yay 7zip bin
yay 7zip
paru 7zip
yay 7zip
ls
kitten +themes
kitten themes
cd kitty
l
rm kitty.conf.bak
rm temp
l
cd config
l
l | where -help
l | where --help
l
l | where --help
l | where name =~ "nu"
l | where name =~ "nush"
l | where name =~ "nushell"
git add .config/nushell/
git add --help
tldr git add
git add .config/nushell/*
git status
git add .config/nushell/
l .config/nushell/
la .config/nushell/
ls -la .config/nushell/
rm .config/nushell/.git
rm -r .config/nushell/.git
